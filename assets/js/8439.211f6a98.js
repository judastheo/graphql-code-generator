"use strict";(self.webpackChunk_graphql_codegen_website=self.webpackChunk_graphql_codegen_website||[]).push([[8439],{68439:function(e,n,i){i.d(n,{jf:function(){return ee}});var t,o=i(83755),s=i(12640),r=i(79945),l=i(43903),c=i(37358),a=i(33277),u=i(23476),d=i(57554),f=i(65449),v=i(14734),p=i(82299);function E(e,n){if(!e||Array.isArray(e)&&0===e.length)return{};if(!Array.isArray(e))return e;if(1===e.length)return e[0]||{};const i=new Array;for(let o of e)Array.isArray(o)&&(o=E(o)),"object"==typeof o&&o&&i.push(o);const t=(0,c.Ee)(i,!0);if(null==n?void 0:n.exclusions)for(const o of n.exclusions){const[e,n]=o.split(".");n&&"*"!==n?t[e]&&delete t[e][n]:delete t[e]}return t}function T(e,n,i){const t=[...n,...e].filter(c.pC).reduce(((e,n)=>e.find((e=>e.name.value===n.name.value))?e:e.concat([n])),[]);return i&&i.sort&&t.sort(c.YU),t}function m(e,n){return!!e.find((e=>e.name.value===n.name.value))}function y(e,n){const i=[...n];for(const t of e){const e=i.findIndex((e=>e.name.value===t.name.value));if(e>-1){const n=i[e];if("ListValue"===n.value.kind){const e=n.value.values,i=t.value.values;n.value.values=_(e,i,((e,n)=>{const i=e.value;return!i||!n.some((e=>e.value===i))}))}else n.value=t.value}else i.push(t)}return i}function h(e=[],n=[],i){const t=i&&i.reverseDirectives,o=t?n:e,s=[...t?e:n].map(((e,n,i)=>{const t=i.findIndex((n=>n.name.value===e.name.value));if(t!==n){const n=i[t];return e.arguments=y(e.arguments,n.arguments),null}return e})).filter(c.pC);for(const r of o)if(m(s,r)){const e=s.findIndex((e=>e.name.value===r.name.value)),n=s[e];s[e].arguments=y(r.arguments||[],n.arguments||[])}else s.push(r);return s}function N(e,n){return n?(function(e,n){const i=(0,a.S)({...e,description:void 0}),t=(0,a.S)({...n,description:void 0}),o=new RegExp("(directive @w*d*)|( on .*$)","g");if(i.replace(o,"")!==t.replace(o,""))throw new Error(`Unable to merge GraphQL directive "${e.name.value}". \nExisting directive:  \n\t${t} \nReceived directive: \n\t${i}`)}(e,n),{...e,locations:[...n.locations,...e.locations.filter((e=>!function(e,n){return n.some((({value:n})=>n===e.value))}(e,n.locations)))]}):e}function _(e,n,i){return e.concat(n.filter((n=>i(n,e))))}function x(e,n,i){if(null==i?void 0:i.consistentEnumMerge){const i=[];e&&i.push(...e),e=n,n=i}const t=new Map;if(e)for(const s of e)t.set(s.name.value,s);if(n)for(const s of n){const e=s.name.value;if(t.has(e)){const n=t.get(e);n.description=s.description||n.description,n.directives=h(s.directives,n.directives)}else t.set(e,s)}const o=[...t.values()];return i&&i.sort&&o.sort(c.YU),o}function g(e,n,i){return n?{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"EnumTypeDefinition"===e.kind||"EnumTypeDefinition"===n.kind?"EnumTypeDefinition":"EnumTypeExtension",loc:e.loc,directives:h(e.directives,n.directives,i),values:x(e.values,n.values,i)}:i&&i.convertExtensions?{...e,kind:"EnumTypeDefinition"}:e}function A(e){let n=e;for(;n.kind===d.h.LIST_TYPE||"NonNullType"===n.kind;)n=n.type;return n}function I(e){return e.kind!==d.h.NAMED_TYPE}function O(e){return e.kind===d.h.LIST_TYPE}function b(e){return e.kind===d.h.NON_NULL_TYPE}function S(e){return O(e)?`[${S(e.type)}]`:b(e)?`${S(e.type)}!`:e.name.value}function w(e,n){return null==e&&null==n?t.A_EQUALS_B:null==e?t.A_SMALLER_THAN_B:null==n?t.A_GREATER_THAN_B:e<n?t.A_SMALLER_THAN_B:e>n?t.A_GREATER_THAN_B:t.A_EQUALS_B}function D(e,n,i){const t=e.find((e=>e.name.value===n.name.value));if(t&&!(null==i?void 0:i.ignoreFieldConflicts)){const e=A(t.type),i=A(n.type);if(e.name.value!==i.name.value)throw new Error(`Field "${n.name.value}" already defined with a different type. Declared as "${e.name.value}", but you tried to override with "${i.name.value}"`)}return!!t}function F(e,n,i,t){const o=[];if(null!=i&&o.push(...i),null!=n)for(const s of n)if(D(o,s,t)){const n=o.find((e=>e.name.value===s.name.value));(null==t?void 0:t.ignoreFieldConflicts)||((null==t?void 0:t.throwOnConflict)?k(e,n,s,!1):k(e,n,s,!0),b(s.type)&&!b(n.type)&&(n.type=s.type)),n.arguments=T(s.arguments||[],n.arguments||[],t),n.directives=h(s.directives,n.directives,t),n.description=s.description||n.description}else o.push(s);if(t&&t.sort&&o.sort(c.YU),t&&t.exclusions){const n=t.exclusions;return o.filter((i=>!n.includes(`${e.name.value}.${i.name.value}`)))}return o}function k(e,n,i,t=!1){const o=S(n.type),s=S(i.type);if(o!==s&&!R(n.type,i.type,t))throw new Error(`Field '${e.name.value}.${n.name.value}' changed type from '${o}' to '${s}'`)}function R(e,n,i=!1){if(!I(e)&&!I(n))return e.toString()===n.toString();if(b(n)){return R(b(e)?e.type:e,n.type)}return b(e)?R(n,e,i):!!O(e)&&(O(n)&&R(e.type,n.type)||b(n)&&R(e,n.type))}function j(e,n,i){if(n)try{return{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"InputObjectTypeDefinition"===e.kind||"InputObjectTypeDefinition"===n.kind?"InputObjectTypeDefinition":"InputObjectTypeExtension",loc:e.loc,fields:F(e,e.fields,n.fields,i),directives:h(e.directives,n.directives,i)}}catch(t){throw new Error(`Unable to merge GraphQL input type "${e.name.value}": ${t.message}`)}return i&&i.convertExtensions?{...e,kind:"InputObjectTypeDefinition"}:e}function C(e,n,i){if(n)try{return{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"InterfaceTypeDefinition"===e.kind||"InterfaceTypeDefinition"===n.kind?"InterfaceTypeDefinition":"InterfaceTypeExtension",loc:e.loc,fields:F(e,e.fields,n.fields,i),directives:h(e.directives,n.directives,i)}}catch(t){throw new Error(`Unable to merge GraphQL interface "${e.name.value}": ${t.message}`)}return i&&i.convertExtensions?{...e,kind:"InterfaceTypeDefinition"}:e}function $(e=[],n=[],i={}){const t=[...n,...e.filter((e=>{return i=e,!n.find((e=>e.name.value===i.name.value));var i}))];return i&&i.sort&&t.sort(c.YU),t}function M(e,n,i){if(n)try{return{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"ObjectTypeDefinition"===e.kind||"ObjectTypeDefinition"===n.kind?"ObjectTypeDefinition":"ObjectTypeExtension",loc:e.loc,fields:F(e,e.fields,n.fields,i),directives:h(e.directives,n.directives,i),interfaces:$(e.interfaces,n.interfaces,i)}}catch(t){throw new Error(`Unable to merge GraphQL type "${e.name.value}": ${t.message}`)}return i&&i.convertExtensions?{...e,kind:"ObjectTypeDefinition"}:e}function P(e,n,i){return n?{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"ScalarTypeDefinition"===e.kind||"ScalarTypeDefinition"===n.kind?"ScalarTypeDefinition":"ScalarTypeExtension",loc:e.loc,directives:h(e.directives,n.directives,i)}:i&&i.convertExtensions?{...e,kind:"ScalarTypeDefinition"}:e}function Y(e,n,i){return n?{name:e.name,description:e.description||n.description,directives:h(e.directives,n.directives,i),kind:i&&i.convertExtensions||"UnionTypeDefinition"===e.kind||"UnionTypeDefinition"===n.kind?"UnionTypeDefinition":"UnionTypeExtension",loc:e.loc,types:$(e.types,n.types,i)}:i&&i.convertExtensions?{...e,kind:"UnionTypeDefinition"}:e}!function(e){e[e.A_SMALLER_THAN_B=-1]="A_SMALLER_THAN_B",e[e.A_EQUALS_B=0]="A_EQUALS_B",e[e.A_GREATER_THAN_B=1]="A_GREATER_THAN_B"}(t||(t={}));const U={query:"Query",mutation:"Mutation",subscription:"Subscription"};function L(e=[],n=[]){const i=[];for(const t in U){const o=e.find((e=>e.operation===t))||n.find((e=>e.operation===t));o&&i.push(o)}return i}function B(e,n,i){return n?{kind:e.kind===d.h.SCHEMA_DEFINITION||n.kind===d.h.SCHEMA_DEFINITION?d.h.SCHEMA_DEFINITION:d.h.SCHEMA_EXTENSION,description:e.description||n.description,directives:h(e.directives,n.directives,i),operationTypes:L(e.operationTypes,n.operationTypes)}:(null==i?void 0:i.convertExtensions)?{...e,kind:d.h.SCHEMA_EXTENSION}:e}const H="SCHEMA_DEF_SYMBOL";function q(e,n){(0,c.BX)();const i={kind:d.h.DOCUMENT,definitions:W(e,{useSchemaDefinition:!0,forceSchemaDefinition:!1,throwOnConflict:!1,commentDescriptions:!1,...n})};let t;return t=n&&n.commentDescriptions?(0,c.d2)(i):i,(0,c.BX)(),t}function V(e,n,i=[],t=new Set){if(e&&!t.has(e))if(t.add(e),"function"==typeof e)V(e(),n,i,t);else if(Array.isArray(e))for(const o of e)V(o,n,i,t);else if((0,s.nN)(e)){V((0,c.HA)(e,n).definitions,n,i,t)}else if("string"==typeof e||function(e){return e instanceof u.H}(e)){V((0,f.Qc)(e,n).definitions,n,i,t)}else if("object"==typeof e&&(0,v.Ir)(e))i.push(e);else{if(!(0,c.JW)(e))throw new Error("typeDefs must contain only strings, documents, schemas, or functions, got "+typeof e);V(e.definitions,n,i,t)}return i}function W(e,n){var i,t,o;(0,c.BX)();const s=function(e,n){var i,t,o;const s={};for(const r of e)if("name"in r){const e=null===(i=r.name)||void 0===i?void 0:i.value;if((null==n?void 0:n.commentDescriptions)&&(0,c.Jx)(r),null==e)continue;if((null===(t=null==n?void 0:n.exclusions)||void 0===t?void 0:t.includes(e+".*"))||(null===(o=null==n?void 0:n.exclusions)||void 0===o?void 0:o.includes(e)))delete s[e];else switch(r.kind){case d.h.OBJECT_TYPE_DEFINITION:case d.h.OBJECT_TYPE_EXTENSION:s[e]=M(r,s[e],n);break;case d.h.ENUM_TYPE_DEFINITION:case d.h.ENUM_TYPE_EXTENSION:s[e]=g(r,s[e],n);break;case d.h.UNION_TYPE_DEFINITION:case d.h.UNION_TYPE_EXTENSION:s[e]=Y(r,s[e],n);break;case d.h.SCALAR_TYPE_DEFINITION:case d.h.SCALAR_TYPE_EXTENSION:s[e]=P(r,s[e],n);break;case d.h.INPUT_OBJECT_TYPE_DEFINITION:case d.h.INPUT_OBJECT_TYPE_EXTENSION:s[e]=j(r,s[e],n);break;case d.h.INTERFACE_TYPE_DEFINITION:case d.h.INTERFACE_TYPE_EXTENSION:s[e]=C(r,s[e],n);break;case d.h.DIRECTIVE_DEFINITION:s[e]=N(r,s[e])}}else r.kind!==d.h.SCHEMA_DEFINITION&&r.kind!==d.h.SCHEMA_EXTENSION||(s[H]=B(r,s[H],n));return s}(V(e,n),n);if(null==n?void 0:n.useSchemaDefinition){const e=s[H]||{kind:d.h.SCHEMA_DEFINITION,operationTypes:[]},n=e.operationTypes;for(const i in U){if(!n.find((e=>e.operation===i))){const e=s[U[i]];null!=e&&null!=e.name&&n.push({kind:d.h.OPERATION_TYPE_DEFINITION,type:{kind:d.h.NAMED_TYPE,name:e.name},operation:i})}}null!=(null===(i=null==e?void 0:e.operationTypes)||void 0===i?void 0:i.length)&&e.operationTypes.length>0&&(s[H]=e)}(null==n?void 0:n.forceSchemaDefinition)&&!(null===(o=null===(t=s[H])||void 0===t?void 0:t.operationTypes)||void 0===o?void 0:o.length)&&(s[H]={kind:d.h.SCHEMA_DEFINITION,operationTypes:[{kind:d.h.OPERATION_TYPE_DEFINITION,operation:"query",type:{kind:d.h.NAMED_TYPE,name:{kind:d.h.NAME,value:"Query"}}}]});const r=Object.values(s);if(null==n?void 0:n.sort){const e="function"==typeof n.sort?n.sort:w;r.sort(((n,i)=>{var t,o;return e(null===(t=n.name)||void 0===t?void 0:t.value,null===(o=i.name)||void 0===o?void 0:o.value)}))}return r}function X(e,n){e&&(e.extensions=(0,c.Ee)([e.extensions||{},n||{}]))}function Q(e){const n={schemaExtensions:{},types:{}};return function(e,n){n.onSchema(e);const i=e.getTypeMap();for(const[,t]of Object.entries(i)){const e=(0,o.KA)(t)&&(0,r.u1)(t),i=(0,p.s9)(t);if(!e&&!i)if((0,o.lp)(t)){n.onObjectType(t);const e=t.getFields();for(const[,i]of Object.entries(e)){n.onObjectField(t,i);const e=i.args||[];for(const o of e)n.onObjectFieldArg(t,i,o)}}else if((0,o.oT)(t)){n.onInterface(t);const e=t.getFields();for(const[,i]of Object.entries(e)){n.onInterfaceField(t,i);const e=i.args||[];for(const o of e)n.onInterfaceFieldArg(t,i,o)}}else if((0,o.hL)(t)){n.onInputType(t);const e=t.getFields();for(const[,i]of Object.entries(e))n.onInputFieldType(t,i)}else if((0,o.EN)(t))n.onUnion(t);else if((0,o.KA)(t))n.onScalar(t);else if((0,o.EM)(t)){n.onEnum(t);for(const e of t.getValues())n.onEnumValue(t,e)}}}(e,{onSchema:e=>n.schemaExtensions=e.extensions||{},onObjectType:e=>n.types[e.name]={fields:{},type:"object",extensions:e.extensions||{}},onObjectField:(e,i)=>n.types[e.name].fields[i.name]={arguments:{},extensions:i.extensions||{}},onObjectFieldArg:(e,i,t)=>n.types[e.name].fields[i.name].arguments[t.name]=t.extensions||{},onInterface:e=>n.types[e.name]={fields:{},type:"interface",extensions:e.extensions||{}},onInterfaceField:(e,i)=>n.types[e.name].fields[i.name]={arguments:{},extensions:i.extensions||{}},onInterfaceFieldArg:(e,i,t)=>n.types[e.name].fields[i.name].arguments[t.name]=t.extensions||{},onEnum:e=>n.types[e.name]={values:{},type:"enum",extensions:e.extensions||{}},onEnumValue:(e,i)=>n.types[e.name].values[i.name]=i.extensions||{},onScalar:e=>n.types[e.name]={type:"scalar",extensions:e.extensions||{}},onUnion:e=>n.types[e.name]={type:"union",extensions:e.extensions||{}},onInputType:e=>n.types[e.name]={fields:{},type:"input",extensions:e.extensions||{}},onInputFieldType:(e,i)=>n.types[e.name].fields[i.name]={extensions:i.extensions||{}}}),n}var G=i(30138);function J(e,n,i,t,o){if(i.resolve){if("function"!=typeof i.resolve)throw new Error(`Resolver "${t}.${o}" must be a function`)}else{const i=`Resolver missing for "${t}.${o}".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${e}: 'ignore'\n  }`;if("error"===n)throw new Error(i);"warn"===n&&G.warn(i)}}function K(e,n,i){const t=(0,s.nN)(e)?{schema:e,resolvers:null!=n?n:{},resolverValidationOptions:i}:e;let{schema:l,resolvers:a,defaultFieldResolver:u,resolverValidationOptions:d={},inheritResolversFromInterfaces:f=!1,updateResolversInPlace:v=!1}=t;const{requireResolversToMatchSchema:p="error",requireResolversForResolveType:E}=d,T=f?function(e,n){const i={},t=e.getTypeMap();for(const o in t){const e=t[o];if("getInterfaces"in e){i[o]={};for(const s of e.getInterfaces())if(n[s.name])for(const e in n[s.name])"__isTypeOf"!==e&&e.startsWith("__")||(i[o][e]=n[s.name][e]);const t=n[o];i[o]={...i[o],...t}}else{const e=n[o];null!=e&&(i[o]=e)}}return i}(l,a):a;for(const s in T){const e=T[s];if("object"!==typeof e)throw new Error(`"${s}" defined in resolvers, but has invalid value "${e}". The resolver's value must be of type object.`);const n=l.getType(s);if(null==n){if("ignore"===p)break;throw new Error(`"${s}" defined in resolvers, but not in schema`)}if((0,r.u1)(n))for(const i in e)i.startsWith("__")?n[i.substring(2)]=e[i]:n[i]=e[i];else if((0,o.EM)(n)){const i=n.getValues();for(const t in e)if(!t.startsWith("__")&&!i.some((e=>e.name===t))&&p&&"ignore"!==p)throw new Error(`${n.name}.${t} was defined in resolvers, but not present within ${n.name}`)}else if((0,o.EN)(n)){for(const i in e)if(!i.startsWith("__")&&p&&"ignore"!==p)throw new Error(`${n.name}.${i} was defined in resolvers, but ${n.name} is not an object or interface type`)}else if((0,o.lp)(n)||(0,o.oT)(n))for(const i in e)if(!i.startsWith("__")){if(null==n.getFields()[i]){if(p&&"ignore"!==p)throw new Error(`${s}.${i} defined in resolvers, but not in schema`)}else{const n=e[i];if("function"!=typeof n&&"object"!=typeof n)throw new Error(`Resolver ${s}.${i} must be object or function`)}}}return l=v?function(e,n,i){var t,s,r,l,a,u,d,f,v,p,E,T,m,y,h,N,_,x;const g=e.getTypeMap();for(const c in n){const i=e.getType(c),A=n[c];if((0,o.KA)(i))for(const e in A)e.startsWith("__")?i[e.substring(2)]=A[e]:"astNode"===e&&null!=i.astNode?i.astNode={...i.astNode,description:null!==(r=null===(s=null===(t=A)||void 0===t?void 0:t.astNode)||void 0===s?void 0:s.description)&&void 0!==r?r:i.astNode.description,directives:(null!==(l=i.astNode.directives)&&void 0!==l?l:[]).concat(null!==(d=null===(u=null===(a=A)||void 0===a?void 0:a.astNode)||void 0===u?void 0:u.directives)&&void 0!==d?d:[])}:"extensionASTNodes"===e&&null!=i.extensionASTNodes?i.extensionASTNodes=i.extensionASTNodes.concat(null!==(v=null===(f=A)||void 0===f?void 0:f.extensionASTNodes)&&void 0!==v?v:[]):"extensions"===e&&null!=i.extensions&&null!=A.extensions?i.extensions=Object.assign(Object.create(null),i.extensions,A.extensions):i[e]=A[e];else if((0,o.EM)(i)){const e=i.toConfig(),n=e.values;for(const t in A)t.startsWith("__")?e[t.substring(2)]=A[t]:"astNode"===t&&null!=e.astNode?e.astNode={...e.astNode,description:null!==(T=null===(E=null===(p=A)||void 0===p?void 0:p.astNode)||void 0===E?void 0:E.description)&&void 0!==T?T:e.astNode.description,directives:(null!==(m=e.astNode.directives)&&void 0!==m?m:[]).concat(null!==(N=null===(h=null===(y=A)||void 0===y?void 0:y.astNode)||void 0===h?void 0:h.directives)&&void 0!==N?N:[])}:"extensionASTNodes"===t&&null!=e.extensionASTNodes?e.extensionASTNodes=e.extensionASTNodes.concat(null!==(x=null===(_=A)||void 0===_?void 0:_.extensionASTNodes)&&void 0!==x?x:[]):"extensions"===t&&null!=i.extensions&&null!=A.extensions?i.extensions=Object.assign(Object.create(null),i.extensions,A.extensions):n[t]&&(n[t].value=A[t]);g[c]=new o.mR(e)}else if((0,o.EN)(i))for(const e in A)e.startsWith("__")&&(i[e.substring(2)]=A[e]);else if((0,o.lp)(i)||(0,o.oT)(i))for(const e in A){if(e.startsWith("__")){i[e.substring(2)]=A[e];break}const n=i.getFields()[e];if(null!=n){const i=A[e];"function"==typeof i?n.resolve=i.bind(A):z(n,i)}}}(0,c.pD)(e,c.RF),(0,c.r8)(e),(0,c.pD)(e,c.Oe),null!=i&&(0,c.pY)(e,(e=>{e.resolve||(e.resolve=i)}));return e}(l,T,u):function(e,n,i){e=(0,c.gf)(e,{[c.h0.SCALAR_TYPE]:e=>{var i,t,s,l,c,a,u,d,f;const v=e.toConfig(),p=n[e.name];if(!(0,r.u1)(e)&&null!=p){for(const n in p)n.startsWith("__")?v[n.substring(2)]=p[n]:"astNode"===n&&null!=v.astNode?v.astNode={...v.astNode,description:null!==(s=null===(t=null===(i=p)||void 0===i?void 0:i.astNode)||void 0===t?void 0:t.description)&&void 0!==s?s:v.astNode.description,directives:(null!==(l=v.astNode.directives)&&void 0!==l?l:[]).concat(null!==(u=null===(a=null===(c=p)||void 0===c?void 0:c.astNode)||void 0===a?void 0:a.directives)&&void 0!==u?u:[])}:"extensionASTNodes"===n&&null!=v.extensionASTNodes?v.extensionASTNodes=v.extensionASTNodes.concat(null!==(f=null===(d=p)||void 0===d?void 0:d.extensionASTNodes)&&void 0!==f?f:[]):"extensions"===n&&null!=v.extensions&&null!=p.extensions?v.extensions=Object.assign(Object.create(null),e.extensions,p.extensions):v[n]=p[n];return new o.n2(v)}},[c.h0.ENUM_TYPE]:e=>{var i,t,s,r,l,c,a,u,d;const f=n[e.name],v=e.toConfig(),p=v.values;if(null!=f){for(const n in f)n.startsWith("__")?v[n.substring(2)]=f[n]:"astNode"===n&&null!=v.astNode?v.astNode={...v.astNode,description:null!==(s=null===(t=null===(i=f)||void 0===i?void 0:i.astNode)||void 0===t?void 0:t.description)&&void 0!==s?s:v.astNode.description,directives:(null!==(r=v.astNode.directives)&&void 0!==r?r:[]).concat(null!==(a=null===(c=null===(l=f)||void 0===l?void 0:l.astNode)||void 0===c?void 0:c.directives)&&void 0!==a?a:[])}:"extensionASTNodes"===n&&null!=v.extensionASTNodes?v.extensionASTNodes=v.extensionASTNodes.concat(null!==(d=null===(u=f)||void 0===u?void 0:u.extensionASTNodes)&&void 0!==d?d:[]):"extensions"===n&&null!=v.extensions&&null!=f.extensions?v.extensions=Object.assign(Object.create(null),e.extensions,f.extensions):p[n]&&(p[n].value=f[n]);return new o.mR(v)}},[c.h0.UNION_TYPE]:e=>{const i=n[e.name];if(null!=i){const n=e.toConfig();return i.__resolveType&&(n.resolveType=i.__resolveType),new o.Gp(n)}},[c.h0.OBJECT_TYPE]:e=>{const i=n[e.name];if(null!=i){const n=e.toConfig();return i.__isTypeOf&&(n.isTypeOf=i.__isTypeOf),new o.h6(n)}},[c.h0.INTERFACE_TYPE]:e=>{const i=n[e.name];if(null!=i){const n=e.toConfig();return i.__resolveType&&(n.resolveType=i.__resolveType),new o.oW(n)}},[c.h0.COMPOSITE_FIELD]:(e,i,t)=>{const o=n[t];if(null!=o){const n=o[i];if(null!=n){const i={...e};return"function"==typeof n?i.resolve=n.bind(o):z(i,n),i}}}}),null!=i&&(e=(0,c.gf)(e,{[c.h0.OBJECT_FIELD]:e=>({...e,resolve:null!=e.resolve?e.resolve:i})}));return e}(l,T,u),E&&"ignore"!==E&&function(e,n){(0,c.gf)(e,{[c.h0.ABSTRACT_TYPE]:e=>{if(!e.resolveType){const i=`Type "${e.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;if("error"===n)throw new Error(i);"warn"===n&&G.warn(i)}}})}(l,E),l}function z(e,n){for(const i in n)e[i]=n[i]}function Z({typeDefs:e,resolvers:n={},resolverValidationOptions:i={},parseOptions:t={},inheritResolversFromInterfaces:r=!1,pruningOptions:a,updateResolversInPlace:u=!1,schemaExtensions:d}){if("object"!=typeof i)throw new Error("Expected `resolverValidationOptions` to be an object");if(!e)throw new Error("Must provide typeDefs");let f;if((0,s.nN)(e))f=e;else if(null==t?void 0:t.commentDescriptions){const n=q(e,{...t,commentDescriptions:!0});f=(0,l.I)(n,t)}else{const n=q(e,t);f=(0,l.M)(n,t)}var v;return a&&(f=(0,c.h1)(f)),f=K({schema:f,resolvers:E(n),resolverValidationOptions:i,inheritResolversFromInterfaces:r,updateResolversInPlace:u}),Object.keys(i).length>0&&function(e,n={}){const{requireResolversForArgs:i,requireResolversForNonScalar:t,requireResolversForAllFields:s}=n;if(s&&(i||t))throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");(0,c.pY)(e,((e,n,r)=>{s&&J("requireResolversForAllFields",s,e,n,r),i&&e.args.length>0&&J("requireResolversForArgs",i,e,n,r),"ignore"===t||(0,o.KA)((0,o.xC)(e.type))||J("requireResolversForNonScalar",t,e,n,r)}))}(f,i),d&&(v=(0,c._2)(d),function(e,n){X(e,n.schemaExtensions);for(const[i,t]of Object.entries(n.types||{})){const n=e.getType(i);if(n)if(X(n,t.extensions),"object"===t.type||"interface"===t.type)for(const[e,i]of Object.entries(t.fields)){const t=n.getFields()[e];if(t){X(t,i.extensions);for(const[e,n]of Object.entries(i.arguments))X(t.args.find((n=>n.name===e)),n)}}else if("input"===t.type)for(const[e,i]of Object.entries(t.fields))X(n.getFields()[e],i.extensions);else if("enum"===t.type)for(const[e,i]of Object.entries(t.values))X(n.getValue(e),i)}}(f,d=(0,c.Ee)(v))),f}function ee(e){const n=(0,c._2)(e.typeDefs||[]),i=(0,c._2)(e.resolvers||[]),t=(0,c._2)(e.schemaExtensions||[]),o=e.schemas||[];for(const s of o)n.push(s),i.push((0,c.wq)(s)),t.push(Q(s));return Z({parseOptions:e,...e,typeDefs:n,resolvers:i,schemaExtensions:t})}}}]);